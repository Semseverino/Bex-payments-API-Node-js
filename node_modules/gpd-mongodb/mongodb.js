'use strict';

class Mongodb {
  constructor(client, collection) {
    this._state = client;
    this._collection = collection;
  }

  _isObject(obj) {
    return Object.keys(obj).length > 0;
  }

  /**
 * Returns the mongodb collection.
 */
  GetCollection() {
    return this._state.Db().collection(this._collection);
  }

  /**
   * Inserts a document into a collection.
   * @param {document} document
   */
  async InsertOne(document) {
    if (!this._isObject(document)) throw new Error('document is not an object');
    return this._state.Db().collection(this._collection)
      .insertOne(document);
  }

  /**
   * Selects documents in a collection or view and returns a cursor to the selected documents.
   * @param {document} filter - Optional. Specifies selection filter using query operators.
   * @param {document} projection - Optional.
   *  Specifies the fields to return in the documents that match the query filter.
   * @param {document} options - Optional.
   * @example ({ status: 'APPROVED' }, {}, { limit: 5 })
   */
  async FindByFilter(filter, projection = {}, options = {}) {
    if (!filter) throw new Error('query is not an object');
    return this._state.Db().collection(this._collection)
      .find(filter, { projection, ...options })
      .toArray();
  }

  /**
   * Filters the documents to pass only the documents that match the specified condition(s) to the next pipeline stage.
   * @param pipeline - A sequence of data aggregation operations or stages.
   * @param options - Optional. Additional options that aggregate() passes to the aggregate command.
   * @example ({ $match: { status: 'APPROVED' } })
   */
  async FindByAggregation(pipeline, options = {}) {
    if (!this._isObject(pipeline)) throw new Error('query is not an object');
    return this._state.Db().collection(this._collection)
      .aggregate(pipeline, options)
      .toArray();
  }

  /**
   * Updates a single document based on the filter and sort criteria.
   * @param {object} filter - The selection criteria for the update.
   * @param {object} update - The update document.
   * @param {object} options - Optional.
   * @example ({ seller_order_id: 'order123' }, { $set: { status: 'APPROVED' } })
   */
  async FindOneAndUpdate(filter, update, options = {}) {
    if (!this._isObject(filter) && !this._isObject(update)) throw new Error('query and values should be an object');
    return this._state.Db().collection(this._collection)
      .findOneAndUpdate(filter, update, options);
  }

  /**
   * Updates a single document within the collection based on the filter.
   * @param {document} filter - The selection criteria for the update
   * @param {document} document - The modifications to apply.
   * @param {document} options - Optional.
   * @example ({ seller_order_id: 'order123' }, { $set: { status: 'APPROVED' } })
   */
  async UpdateOne(filter, document, options = {}) {
    if (!this._isObject(filter) && !this._isObject(document)) throw new Error('query and values should be an object');
    return this._state.Db().collection(this._collection)
      .updateOne(filter, document, options);
  }

  /**
   * Updates Many documents based on the filter.
   * @param {document} filter - The selection criteria for the update
   * @param {document} document - The modifications to apply.
   * @param {document} options - Optional.
   * @example ({ seller_id: 'meu-seller-legalzao' }, { $set: { status: 'EXPIRED' } })
   */
  async updateMany(filter, document, options = {}) {
    if (!this._isObject(filter) && !this._isObject(document)) throw new Error('query and values should be an object');
    return this._state.Db().collection(this._collection)
      .updateMany(filter, document, options);
  }
}

module.exports = Mongodb;
